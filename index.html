<html>
  <head>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
    </style>
    <script>
      function bootstrap() {
        fetch('TH.json')
          .then(res => res.json())
          .then(data => {
            window.TH = data;
            console.log(data);
          })
          .catch((error) => {
            console.error(error);
          });
      }

      window._fetchPromises = {};
      window._fetch = fetch;
      window.fetch = (urlString, options = {}) => {
        const url = new URL(urlString, window.location.origin);
        // Intercept POST requests to this domain and route them to our server
        if (url.origin == window.location.origin && options.method === 'POST') {
          console.log('Intercepting POST');
          // Call server
          const arr = [];
          window.crypto.getRandomValues(new window.Uint8ClampedArray(16))
            .forEach((e) => arr.push(e.toString(16)));
          const uuid = arr.join('');
          const promise = new Promise((resolve) => {
            window._fetchPromises[uuid] = resolve;
          })
          window.server.postMessage(JSON.stringify({
            id: uuid,
            cmd: 'REQUEST',
            data: {
              url: url.pathname,
              body: options.body
            }
          }));
          return promise;
        }
        return window._fetch(urlString, options);
      }

      window.server = new Worker('server.js');
      window.server.onmessage = (e) => {
        const message = JSON.parse(e.data);
        if (window._fetchPromises[message.id] === undefined) {
          return console.error(`Missing promise for request ${message.id}`);
        }
        const response = new Response(message.data.body, {status: message.data.status});
        window._fetchPromises[message.id].call(response, response);
        delete window._fetchPromises[message.id];
      };
      // Wait until the sw is ready before we start bootstrapping
      // We use setTimeout so fetch gets intercepted by the sw
      navigator.serviceWorker.ready.then((e) => setTimeout(bootstrap, 0));
      navigator.serviceWorker.register('/sw.js');
    </script>
  </head>
  <body>
    Loading...
  </body>
</html>
